// @generated by protoc-gen-es v1.2.0
// @generated from file meshtastic/module_config.proto (package meshtastic, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 *
 * Module Config
 *
 * @generated from message meshtastic.ModuleConfig
 */
export declare class ModuleConfig extends Message<ModuleConfig> {
  /**
   *
   * TODO: REPLACE
   *
   * @generated from oneof meshtastic.ModuleConfig.payload_variant
   */
  payloadVariant: {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.MQTTConfig mqtt = 1;
     */
    value: ModuleConfig_MQTTConfig;
    case: "mqtt";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.SerialConfig serial = 2;
     */
    value: ModuleConfig_SerialConfig;
    case: "serial";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.ExternalNotificationConfig external_notification = 3;
     */
    value: ModuleConfig_ExternalNotificationConfig;
    case: "externalNotification";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.StoreForwardConfig store_forward = 4;
     */
    value: ModuleConfig_StoreForwardConfig;
    case: "storeForward";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.RangeTestConfig range_test = 5;
     */
    value: ModuleConfig_RangeTestConfig;
    case: "rangeTest";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.TelemetryConfig telemetry = 6;
     */
    value: ModuleConfig_TelemetryConfig;
    case: "telemetry";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.CannedMessageConfig canned_message = 7;
     */
    value: ModuleConfig_CannedMessageConfig;
    case: "cannedMessage";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.AudioConfig audio = 8;
     */
    value: ModuleConfig_AudioConfig;
    case: "audio";
  } | {
    /**
     *
     * TODO: REPLACE
     *
     * @generated from field: meshtastic.ModuleConfig.RemoteHardwareConfig remote_hardware = 9;
     */
    value: ModuleConfig_RemoteHardwareConfig;
    case: "remoteHardware";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ModuleConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig;

  static equals(a: ModuleConfig | PlainMessage<ModuleConfig> | undefined, b: ModuleConfig | PlainMessage<ModuleConfig> | undefined): boolean;
}

/**
 *
 * MQTT Client Config
 *
 * @generated from message meshtastic.ModuleConfig.MQTTConfig
 */
export declare class ModuleConfig_MQTTConfig extends Message<ModuleConfig_MQTTConfig> {
  /**
   *
   * If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
   * is_uplink_enabled or is_downlink_enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * The server to use for our MQTT global message gateway feature.
   * If not set, the default server will be used
   *
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   *
   * MQTT username to use (most useful for a custom MQTT server).
   * If using a custom server, this will be honoured even if empty.
   * If using the default server, this will only be honoured if set, otherwise the device will use the default username
   *
   * @generated from field: string username = 3;
   */
  username: string;

  /**
   *
   * MQTT password to use (most useful for a custom MQTT server).
   * If using a custom server, this will be honoured even if empty.
   * If using the default server, this will only be honoured if set, otherwise the device will use the default password
   *
   * @generated from field: string password = 4;
   */
  password: string;

  /**
   *
   * Whether to send encrypted or decrypted packets to MQTT.
   * This parameter is only honoured if you also set server
   * (the default official mqtt.meshtastic.org server can handle encrypted packets)
   * Decrypted packets may be useful for external systems that want to consume meshtastic packets
   *
   * @generated from field: bool encryption_enabled = 5;
   */
  encryptionEnabled: boolean;

  /**
   *
   * Whether to send / consume json packets on MQTT
   *
   * @generated from field: bool json_enabled = 6;
   */
  jsonEnabled: boolean;

  constructor(data?: PartialMessage<ModuleConfig_MQTTConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig.MQTTConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig_MQTTConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig_MQTTConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig_MQTTConfig;

  static equals(a: ModuleConfig_MQTTConfig | PlainMessage<ModuleConfig_MQTTConfig> | undefined, b: ModuleConfig_MQTTConfig | PlainMessage<ModuleConfig_MQTTConfig> | undefined): boolean;
}

/**
 *
 * RemoteHardwareModule Config
 *
 * @generated from message meshtastic.ModuleConfig.RemoteHardwareConfig
 */
export declare class ModuleConfig_RemoteHardwareConfig extends Message<ModuleConfig_RemoteHardwareConfig> {
  /**
   *
   * Whether the Module is enabled
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  constructor(data?: PartialMessage<ModuleConfig_RemoteHardwareConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig.RemoteHardwareConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig_RemoteHardwareConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig_RemoteHardwareConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig_RemoteHardwareConfig;

  static equals(a: ModuleConfig_RemoteHardwareConfig | PlainMessage<ModuleConfig_RemoteHardwareConfig> | undefined, b: ModuleConfig_RemoteHardwareConfig | PlainMessage<ModuleConfig_RemoteHardwareConfig> | undefined): boolean;
}

/**
 *
 * Audio Config for codec2 voice
 *
 * @generated from message meshtastic.ModuleConfig.AudioConfig
 */
export declare class ModuleConfig_AudioConfig extends Message<ModuleConfig_AudioConfig> {
  /**
   *
   * Whether Audio is enabled
   *
   * @generated from field: bool codec2_enabled = 1;
   */
  codec2Enabled: boolean;

  /**
   *
   * PTT Pin
   *
   * @generated from field: uint32 ptt_pin = 2;
   */
  pttPin: number;

  /**
   *
   * The audio sample rate to use for codec2
   *
   * @generated from field: meshtastic.ModuleConfig.AudioConfig.Audio_Baud bitrate = 3;
   */
  bitrate: ModuleConfig_AudioConfig_Audio_Baud;

  /**
   *
   * I2S Word Select
   *
   * @generated from field: uint32 i2s_ws = 4;
   */
  i2sWs: number;

  /**
   *
   * I2S Data IN
   *
   * @generated from field: uint32 i2s_sd = 5;
   */
  i2sSd: number;

  /**
   *
   * I2S Data OUT
   *
   * @generated from field: uint32 i2s_din = 6;
   */
  i2sDin: number;

  /**
   *
   * I2S Clock
   *
   * @generated from field: uint32 i2s_sck = 7;
   */
  i2sSck: number;

  constructor(data?: PartialMessage<ModuleConfig_AudioConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig.AudioConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig_AudioConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig_AudioConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig_AudioConfig;

  static equals(a: ModuleConfig_AudioConfig | PlainMessage<ModuleConfig_AudioConfig> | undefined, b: ModuleConfig_AudioConfig | PlainMessage<ModuleConfig_AudioConfig> | undefined): boolean;
}

/**
 *
 * Baudrate for codec2 voice
 *
 * @generated from enum meshtastic.ModuleConfig.AudioConfig.Audio_Baud
 */
export declare enum ModuleConfig_AudioConfig_Audio_Baud {
  /**
   * @generated from enum value: CODEC2_DEFAULT = 0;
   */
  CODEC2_DEFAULT = 0,

  /**
   * @generated from enum value: CODEC2_3200 = 1;
   */
  CODEC2_3200 = 1,

  /**
   * @generated from enum value: CODEC2_2400 = 2;
   */
  CODEC2_2400 = 2,

  /**
   * @generated from enum value: CODEC2_1600 = 3;
   */
  CODEC2_1600 = 3,

  /**
   * @generated from enum value: CODEC2_1400 = 4;
   */
  CODEC2_1400 = 4,

  /**
   * @generated from enum value: CODEC2_1300 = 5;
   */
  CODEC2_1300 = 5,

  /**
   * @generated from enum value: CODEC2_1200 = 6;
   */
  CODEC2_1200 = 6,

  /**
   * @generated from enum value: CODEC2_700 = 7;
   */
  CODEC2_700 = 7,

  /**
   * @generated from enum value: CODEC2_700B = 8;
   */
  CODEC2_700B = 8,
}

/**
 *
 * Serial Config
 *
 * @generated from message meshtastic.ModuleConfig.SerialConfig
 */
export declare class ModuleConfig_SerialConfig extends Message<ModuleConfig_SerialConfig> {
  /**
   *
   * Preferences for the SerialModule
   * FIXME - Move this out of UserPreferences and into a section for module configuration.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: bool echo = 2;
   */
  echo: boolean;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 rxd = 3;
   */
  rxd: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 txd = 4;
   */
  txd: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: meshtastic.ModuleConfig.SerialConfig.Serial_Baud baud = 5;
   */
  baud: ModuleConfig_SerialConfig_Serial_Baud;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 timeout = 6;
   */
  timeout: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: meshtastic.ModuleConfig.SerialConfig.Serial_Mode mode = 7;
   */
  mode: ModuleConfig_SerialConfig_Serial_Mode;

  constructor(data?: PartialMessage<ModuleConfig_SerialConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig.SerialConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig_SerialConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig_SerialConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig_SerialConfig;

  static equals(a: ModuleConfig_SerialConfig | PlainMessage<ModuleConfig_SerialConfig> | undefined, b: ModuleConfig_SerialConfig | PlainMessage<ModuleConfig_SerialConfig> | undefined): boolean;
}

/**
 *
 * TODO: REPLACE
 *
 * @generated from enum meshtastic.ModuleConfig.SerialConfig.Serial_Baud
 */
export declare enum ModuleConfig_SerialConfig_Serial_Baud {
  /**
   * @generated from enum value: BAUD_DEFAULT = 0;
   */
  BAUD_DEFAULT = 0,

  /**
   * @generated from enum value: BAUD_110 = 1;
   */
  BAUD_110 = 1,

  /**
   * @generated from enum value: BAUD_300 = 2;
   */
  BAUD_300 = 2,

  /**
   * @generated from enum value: BAUD_600 = 3;
   */
  BAUD_600 = 3,

  /**
   * @generated from enum value: BAUD_1200 = 4;
   */
  BAUD_1200 = 4,

  /**
   * @generated from enum value: BAUD_2400 = 5;
   */
  BAUD_2400 = 5,

  /**
   * @generated from enum value: BAUD_4800 = 6;
   */
  BAUD_4800 = 6,

  /**
   * @generated from enum value: BAUD_9600 = 7;
   */
  BAUD_9600 = 7,

  /**
   * @generated from enum value: BAUD_19200 = 8;
   */
  BAUD_19200 = 8,

  /**
   * @generated from enum value: BAUD_38400 = 9;
   */
  BAUD_38400 = 9,

  /**
   * @generated from enum value: BAUD_57600 = 10;
   */
  BAUD_57600 = 10,

  /**
   * @generated from enum value: BAUD_115200 = 11;
   */
  BAUD_115200 = 11,

  /**
   * @generated from enum value: BAUD_230400 = 12;
   */
  BAUD_230400 = 12,

  /**
   * @generated from enum value: BAUD_460800 = 13;
   */
  BAUD_460800 = 13,

  /**
   * @generated from enum value: BAUD_576000 = 14;
   */
  BAUD_576000 = 14,

  /**
   * @generated from enum value: BAUD_921600 = 15;
   */
  BAUD_921600 = 15,
}

/**
 *
 * TODO: REPLACE
 *
 * @generated from enum meshtastic.ModuleConfig.SerialConfig.Serial_Mode
 */
export declare enum ModuleConfig_SerialConfig_Serial_Mode {
  /**
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * @generated from enum value: SIMPLE = 1;
   */
  SIMPLE = 1,

  /**
   * @generated from enum value: PROTO = 2;
   */
  PROTO = 2,

  /**
   * @generated from enum value: TEXTMSG = 3;
   */
  TEXTMSG = 3,

  /**
   * @generated from enum value: NMEA = 4;
   */
  NMEA = 4,
}

/**
 *
 * External Notifications Config
 *
 * @generated from message meshtastic.ModuleConfig.ExternalNotificationConfig
 */
export declare class ModuleConfig_ExternalNotificationConfig extends Message<ModuleConfig_ExternalNotificationConfig> {
  /**
   *
   * Enable the ExternalNotificationModule
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * When using in On/Off mode, keep the output on for this many
   * milliseconds. Default 1000ms (1 second).
   *
   * @generated from field: uint32 output_ms = 2;
   */
  outputMs: number;

  /**
   *
   * Define the output pin GPIO setting Defaults to
   * EXT_NOTIFY_OUT if set for the board.
   * In standalone devices this pin should drive the LED to match the UI.
   *
   * @generated from field: uint32 output = 3;
   */
  output: number;

  /**
   *
   * Optional: Define a secondary output pin for a vibra motor
   * This is used in standalone devices to match the UI.
   *
   * @generated from field: uint32 output_vibra = 8;
   */
  outputVibra: number;

  /**
   *
   * Optional: Define a tertiary output pin for an active buzzer
   * This is used in standalone devices to to match the UI.
   *
   * @generated from field: uint32 output_buzzer = 9;
   */
  outputBuzzer: number;

  /**
   *
   * IF this is true, the 'output' Pin will be pulled active high, false
   * means active low.
   *
   * @generated from field: bool active = 4;
   */
  active: boolean;

  /**
   *
   * True: Alert when a text message arrives (output)
   *
   * @generated from field: bool alert_message = 5;
   */
  alertMessage: boolean;

  /**
   *
   * True: Alert when a text message arrives (output_vibra)
   *
   * @generated from field: bool alert_message_vibra = 10;
   */
  alertMessageVibra: boolean;

  /**
   *
   * True: Alert when a text message arrives (output_buzzer)
   *
   * @generated from field: bool alert_message_buzzer = 11;
   */
  alertMessageBuzzer: boolean;

  /**
   *
   * True: Alert when the bell character is received (output)
   *
   * @generated from field: bool alert_bell = 6;
   */
  alertBell: boolean;

  /**
   *
   * True: Alert when the bell character is received (output_vibra)
   *
   * @generated from field: bool alert_bell_vibra = 12;
   */
  alertBellVibra: boolean;

  /**
   *
   * True: Alert when the bell character is received (output_buzzer)
   *
   * @generated from field: bool alert_bell_buzzer = 13;
   */
  alertBellBuzzer: boolean;

  /**
   *
   * use a PWM output instead of a simple on/off output. This will ignore
   * the 'output', 'output_ms' and 'active' settings and use the
   * device.buzzer_gpio instead.
   *
   * @generated from field: bool use_pwm = 7;
   */
  usePwm: boolean;

  /**
   *
   * The notification will toggle with 'output_ms' for this time of seconds.
   * Default is 0 which means don't repeat at all. 60 would mean blink
   * and/or beep for 60 seconds
   *
   * @generated from field: uint32 nag_timeout = 14;
   */
  nagTimeout: number;

  constructor(data?: PartialMessage<ModuleConfig_ExternalNotificationConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig.ExternalNotificationConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig_ExternalNotificationConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig_ExternalNotificationConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig_ExternalNotificationConfig;

  static equals(a: ModuleConfig_ExternalNotificationConfig | PlainMessage<ModuleConfig_ExternalNotificationConfig> | undefined, b: ModuleConfig_ExternalNotificationConfig | PlainMessage<ModuleConfig_ExternalNotificationConfig> | undefined): boolean;
}

/**
 *
 * Store and Forward Module Config
 *
 * @generated from message meshtastic.ModuleConfig.StoreForwardConfig
 */
export declare class ModuleConfig_StoreForwardConfig extends Message<ModuleConfig_StoreForwardConfig> {
  /**
   *
   * Enable the Store and Forward Module
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: bool heartbeat = 2;
   */
  heartbeat: boolean;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 records = 3;
   */
  records: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 history_return_max = 4;
   */
  historyReturnMax: number;

  /**
   *
   * TODO: REPLACE
   *
   * @generated from field: uint32 history_return_window = 5;
   */
  historyReturnWindow: number;

  constructor(data?: PartialMessage<ModuleConfig_StoreForwardConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig.StoreForwardConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig_StoreForwardConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig_StoreForwardConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig_StoreForwardConfig;

  static equals(a: ModuleConfig_StoreForwardConfig | PlainMessage<ModuleConfig_StoreForwardConfig> | undefined, b: ModuleConfig_StoreForwardConfig | PlainMessage<ModuleConfig_StoreForwardConfig> | undefined): boolean;
}

/**
 *
 * Preferences for the RangeTestModule
 *
 * @generated from message meshtastic.ModuleConfig.RangeTestConfig
 */
export declare class ModuleConfig_RangeTestConfig extends Message<ModuleConfig_RangeTestConfig> {
  /**
   *
   * Enable the Range Test Module
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   *
   * Send out range test messages from this node
   *
   * @generated from field: uint32 sender = 2;
   */
  sender: number;

  /**
   *
   * Bool value indicating that this node should save a RangeTest.csv file. 
   * ESP32 Only
   *
   * @generated from field: bool save = 3;
   */
  save: boolean;

  constructor(data?: PartialMessage<ModuleConfig_RangeTestConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig.RangeTestConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig_RangeTestConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig_RangeTestConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig_RangeTestConfig;

  static equals(a: ModuleConfig_RangeTestConfig | PlainMessage<ModuleConfig_RangeTestConfig> | undefined, b: ModuleConfig_RangeTestConfig | PlainMessage<ModuleConfig_RangeTestConfig> | undefined): boolean;
}

/**
 *
 * Configuration for both device and environment metrics
 *
 * @generated from message meshtastic.ModuleConfig.TelemetryConfig
 */
export declare class ModuleConfig_TelemetryConfig extends Message<ModuleConfig_TelemetryConfig> {
  /**
   *
   * Interval in seconds of how often we should try to send our
   * device metrics to the mesh
   *
   * @generated from field: uint32 device_update_interval = 1;
   */
  deviceUpdateInterval: number;

  /**
   * @generated from field: uint32 environment_update_interval = 2;
   */
  environmentUpdateInterval: number;

  /**
   *
   * Preferences for the Telemetry Module (Environment)
   * Enable/Disable the telemetry measurement module measurement collection
   *
   * @generated from field: bool environment_measurement_enabled = 3;
   */
  environmentMeasurementEnabled: boolean;

  /**
   *
   * Enable/Disable the telemetry measurement module on-device display
   *
   * @generated from field: bool environment_screen_enabled = 4;
   */
  environmentScreenEnabled: boolean;

  /**
   *
   * We'll always read the sensor in Celsius, but sometimes we might want to
   * display the results in Fahrenheit as a "user preference".
   *
   * @generated from field: bool environment_display_fahrenheit = 5;
   */
  environmentDisplayFahrenheit: boolean;

  /**
   *
   * Enable/Disable the air quality metrics
   *
   * @generated from field: bool air_quality_enabled = 6;
   */
  airQualityEnabled: boolean;

  /**
   *
   * Interval in seconds of how often we should try to send our
   * air quality metrics to the mesh
   *
   * @generated from field: uint32 air_quality_interval = 7;
   */
  airQualityInterval: number;

  constructor(data?: PartialMessage<ModuleConfig_TelemetryConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig.TelemetryConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig_TelemetryConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig_TelemetryConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig_TelemetryConfig;

  static equals(a: ModuleConfig_TelemetryConfig | PlainMessage<ModuleConfig_TelemetryConfig> | undefined, b: ModuleConfig_TelemetryConfig | PlainMessage<ModuleConfig_TelemetryConfig> | undefined): boolean;
}

/**
 *
 * TODO: REPLACE
 *
 * @generated from message meshtastic.ModuleConfig.CannedMessageConfig
 */
export declare class ModuleConfig_CannedMessageConfig extends Message<ModuleConfig_CannedMessageConfig> {
  /**
   *
   * Enable the rotary encoder #1. This is a 'dumb' encoder sending pulses on both A and B pins while rotating.
   *
   * @generated from field: bool rotary1_enabled = 1;
   */
  rotary1Enabled: boolean;

  /**
   *
   * GPIO pin for rotary encoder A port.
   *
   * @generated from field: uint32 inputbroker_pin_a = 2;
   */
  inputbrokerPinA: number;

  /**
   *
   * GPIO pin for rotary encoder B port.
   *
   * @generated from field: uint32 inputbroker_pin_b = 3;
   */
  inputbrokerPinB: number;

  /**
   *
   * GPIO pin for rotary encoder Press port.
   *
   * @generated from field: uint32 inputbroker_pin_press = 4;
   */
  inputbrokerPinPress: number;

  /**
   *
   * Generate input event on CW of this kind.
   *
   * @generated from field: meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_cw = 5;
   */
  inputbrokerEventCw: ModuleConfig_CannedMessageConfig_InputEventChar;

  /**
   *
   * Generate input event on CCW of this kind.
   *
   * @generated from field: meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_ccw = 6;
   */
  inputbrokerEventCcw: ModuleConfig_CannedMessageConfig_InputEventChar;

  /**
   *
   * Generate input event on Press of this kind.
   *
   * @generated from field: meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_press = 7;
   */
  inputbrokerEventPress: ModuleConfig_CannedMessageConfig_InputEventChar;

  /**
   *
   * Enable the Up/Down/Select input device. Can be RAK rotary encoder or 3 buttons. Uses the a/b/press definitions from inputbroker.
   *
   * @generated from field: bool updown1_enabled = 8;
   */
  updown1Enabled: boolean;

  /**
   *
   * Enable/disable CannedMessageModule.
   *
   * @generated from field: bool enabled = 9;
   */
  enabled: boolean;

  /**
   *
   * Input event origin accepted by the canned message module.
   * Can be e.g. "rotEnc1", "upDownEnc1" or keyword "_any"
   *
   * @generated from field: string allow_input_source = 10;
   */
  allowInputSource: string;

  /**
   *
   * CannedMessageModule also sends a bell character with the messages.
   * ExternalNotificationModule can benefit from this feature.
   *
   * @generated from field: bool send_bell = 11;
   */
  sendBell: boolean;

  constructor(data?: PartialMessage<ModuleConfig_CannedMessageConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "meshtastic.ModuleConfig.CannedMessageConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig_CannedMessageConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig_CannedMessageConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig_CannedMessageConfig;

  static equals(a: ModuleConfig_CannedMessageConfig | PlainMessage<ModuleConfig_CannedMessageConfig> | undefined, b: ModuleConfig_CannedMessageConfig | PlainMessage<ModuleConfig_CannedMessageConfig> | undefined): boolean;
}

/**
 *
 * TODO: REPLACE
 *
 * @generated from enum meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar
 */
export declare enum ModuleConfig_CannedMessageConfig_InputEventChar {
  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: UP = 17;
   */
  UP = 17,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: DOWN = 18;
   */
  DOWN = 18,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: LEFT = 19;
   */
  LEFT = 19,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: RIGHT = 20;
   */
  RIGHT = 20,

  /**
   *
   * '\n'
   *
   * @generated from enum value: SELECT = 10;
   */
  SELECT = 10,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: BACK = 27;
   */
  BACK = 27,

  /**
   *
   * TODO: REPLACE
   *
   * @generated from enum value: CANCEL = 24;
   */
  CANCEL = 24,
}

